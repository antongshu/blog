<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>an</title>
    <description>CrazyAndy's blog,use Jekyll and github pages.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 31 Jul 2017 17:26:36 +0800</pubDate>
    <lastBuildDate>Mon, 31 Jul 2017 17:26:36 +0800</lastBuildDate>
    <generator>Jekyll v3.5.1</generator>
    
      <item>
        <title>Paper Plane</title>
        <description>&lt;center&gt;Paper plane paper plane&lt;/center&gt;
&lt;center&gt;纸飞机 纸飞机&lt;/center&gt;
&lt;center&gt;How soft and light you are&lt;/center&gt;
&lt;center&gt;轻轻的纸飞机&lt;/center&gt;
&lt;center&gt;Hope to ride you in the air&lt;/center&gt;
&lt;center&gt;真想骑着你&lt;/center&gt;
&lt;center&gt;Up to the, high clouds fair&lt;/center&gt;
&lt;center&gt;载我向那高处飞&lt;/center&gt;
&lt;center&gt;Reach abode of heavenly realm&lt;/center&gt;
&lt;center&gt;飞往一处桃源地&lt;/center&gt;
&lt;center&gt;Paper plane paper plane&lt;/center&gt;
&lt;center&gt;纸飞机 纸飞机&lt;/center&gt;
&lt;center&gt;How soft and light you are&lt;/center&gt;
&lt;center&gt;轻轻的纸飞机&lt;/center&gt;
&lt;center&gt;Gracefully flying your wings’pair&lt;/center&gt;
&lt;center&gt;它多么的优美&lt;/center&gt;
&lt;center&gt;Look as ,if to a land rare&lt;/center&gt;
&lt;center&gt;看似漫无目的的在飞&lt;/center&gt;
&lt;center&gt;Yet, you are always there &lt;/center&gt;
&lt;center&gt;却又总会着地&lt;/center&gt;
&lt;center&gt;Mission is what this plane bear&lt;/center&gt;
&lt;center&gt;它总有它的使命&lt;/center&gt;
&lt;center&gt;So let this paper plane&lt;/center&gt;
&lt;center&gt;就像这架纸飞机&lt;/center&gt;
&lt;center&gt;Lightly tapping my sorrowed heart &lt;/center&gt;
&lt;center&gt;轻叩我心扉&lt;/center&gt;
&lt;center&gt;Carrying away all my sads &lt;/center&gt;
&lt;center&gt;载走我的伤悲&lt;/center&gt;

&lt;p&gt;　　&lt;/p&gt;

</description>
        <pubDate>Wed, 05 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/literature/2017/04/05/PaperPlane.html</link>
        <guid isPermaLink="true">http://localhost:4000/literature/2017/04/05/PaperPlane.html</guid>
        
        <category>大时代</category>
        
        <category>方展博</category>
        
        <category>纸飞机</category>
        
        
        <category>literature</category>
        
      </item>
    
      <item>
        <title>呵呵</title>
        <description>&lt;p&gt;　　本节以及接下来的几章将会陆续介绍我根据Spring Boot搭建的web框架。&lt;/p&gt;

&lt;p&gt;　　&lt;/p&gt;

</description>
        <pubDate>Fri, 06 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/boot/2017/01/06/eee.html</link>
        <guid isPermaLink="true">http://localhost:4000/boot/2017/01/06/eee.html</guid>
        
        <category>java</category>
        
        <category>Crawler</category>
        
        
        <category>boot</category>
        
      </item>
    
      <item>
        <title>使用Spring Boot构建web框架(一)</title>
        <description>&lt;p&gt;　　本节以及接下来的几章将会陆续介绍我根据Spring Boot搭建的web框架。&lt;/p&gt;

&lt;p&gt;　　&lt;/p&gt;

</description>
        <pubDate>Sun, 01 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/boot/2017/01/01/SpringBoot.html</link>
        <guid isPermaLink="true">http://localhost:4000/boot/2017/01/01/SpringBoot.html</guid>
        
        <category>java</category>
        
        <category>Crawler</category>
        
        
        <category>boot</category>
        
      </item>
    
      <item>
        <title>黄勇-架构探险-从零开始写Java Web框架</title>
        <description>&lt;p&gt;　　偶然从论坛上看到黄勇老师写的一本书，《架构探险-从零开始写Java Web框架》，读了读绪论和目录，饶有兴趣，于是买来书看一看，感觉使用java web开发这几年来，自己心里对java web框架一些模棱两可的猜测，也有了更清晰的界定。&lt;/p&gt;

&lt;p&gt;　　本书从头边看边敲代码，注解，反射，代理，aop这些虽然再实际开发工作中经常用到，但是了解不深的知识，在这里有了更新的认识，更对java web常用的mvc框架有了进一步的认识，也借此推荐给工作3年以上的java程序开发者看一看，真心有用，至少让我开阔了眼界。&lt;/p&gt;

&lt;p&gt;　　而其中的代码风格，也对我自己有些教育作用，看来还是要多看人家写的优秀代码，别自己闭门造车，否则眼界不够，很容易变成一只井底之蛙。所以，也督促自己以后多看一些开源的项目。勇哥说啦，开源的不仅仅是代码，更重要的是思想，回顾原来自己的技术，感觉特别的薄弱，需要提高的地方还有很多，不多说啦，自己加油吧。&lt;/p&gt;

&lt;p&gt;　　&lt;/p&gt;

</description>
        <pubDate>Mon, 01 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2016/08/01/SmartFrame.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2016/08/01/SmartFrame.html</guid>
        
        <category>java</category>
        
        <category>黄勇</category>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>构建简单的Java 爬虫框架</title>
        <description>&lt;p&gt;　　本节主要介绍该爬虫系统的框架设计。&lt;/p&gt;

&lt;p&gt;　　主要是利用了SpringMvc + Spring quartz + Jsoup 技术，还写了简单的Chrome浏览器插件，供用户用鼠标选择页面内容，生成Xpath爬取规则入库，启动Quartz定时任务，进行爬取。中间遇到了好多问题，尤其是在编写Chrome插件这块，希望能将当时开发的心得体会介绍给大家，如果能帮助到大家，那会是一件很愉悦的事情，也期待大家能联系我多交流技术。&lt;/p&gt;

&lt;p&gt;　　Jsoup是java语言中特有的爬取网页数据技术，它仿照jquery访问页面节点的语法风格，极大的方便了java开发者根据id，class等选择器选择所需节点，并获取页面元素值。也支持通过xpath规则去解析html页面。在爬取的过程中，也遇到了有些页面数据是js动态生成的现象，所以又加入了phantomjs技术支持，如果在jsoup爬取不到的情况下，会调用phantomjs进行爬取。现在市面流行的大多都用python scrapy去写，我暂时还没学习过python，所以就用java去实现，但是非常感兴趣能了解一下scrapy的操作流程，了解人家的设计思想，想必考虑到了爬虫中的方方面面，爬取规则制定，定时任务，应对反爬虫策略的一些独门绝技等等，即便吃不到猪肉，看看猪是怎么跑的也是挺好的(说这句话发觉自己特么的好屌丝)。&lt;/p&gt;

&lt;p&gt;　　本系统中，通过自己研发的chrome插件监听鼠标操作，并根据一定算法计算得到xpath规则，存入数据库中，方便job任务执行爬取操作。&lt;/p&gt;

&lt;p&gt;　　Spring Quartz是一套很不错的定时任务框架，它支持内存插入，xml配置，持久化这三种方式，内存插入如果在系统停止服务的时候就会消失job和定时器；xml配置不灵活，可扩展性差；所以最后还是拥抱了一下持久化方式。而且，Quratz还支持分布式集群功能，好吧，集群我没用到。&lt;/p&gt;

&lt;p&gt;　　在信息分类编辑中，用到了zTree.js插件，并稍微改造了一下，实现bootstrap风格。&lt;/p&gt;

&lt;p&gt;　　本系统分成信息cms系统和爬虫job系统两个子系统，cms制定爬取规则，爬虫job系统根据规则进行爬取，两系统之间采用webservice方式进行通信。&lt;/p&gt;

&lt;p&gt;　　系统页面采用的是inspinia 基于bootstrap的前端模板。&lt;/p&gt;

&lt;p&gt;　　代码编辑器用的是idea project，这是头一回真正使用idea作为项目开发工具，那种感觉真的是太酷了，比eclipse好的不止一星半点，而且占用内存也不大，甚至小于myeclipse。&lt;/p&gt;

&lt;p&gt;　　当然，如果应用在商业用途，还是建议大家使用正版软件，毕竟人家的程序猿也是需要吃饭的，程序猿何苦为难程序猿。&lt;/p&gt;

&lt;p&gt;　　以上就是对这套系统的简单描述，在以后的章节中，我会详细介绍系统实现的每个细节，如果有设计不合理的地方还请各位民间高手不吝赐教，毕竟发现问题是解决问题的第一步。&lt;/p&gt;

&lt;p&gt;如果需要代码，朋友们可通过邮件联系找我要。&lt;/p&gt;

</description>
        <pubDate>Mon, 01 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2016/08/01/Java-Crawler.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2016/08/01/Java-Crawler.html</guid>
        
        <category>java</category>
        
        <category>Crawler</category>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>linux环境搭建</title>
        <description>&lt;p&gt;一、文件上传&lt;/p&gt;

&lt;p&gt;　　(1).创建文件夹&lt;/p&gt;

&lt;p&gt;　　mkdir /itec/upload&lt;/p&gt;

&lt;p&gt;　　(2)上传文件&lt;/p&gt;

&lt;p&gt;　　apache-tomcat-7.0.68(文件夹)
　　MySQL-5.6.29-1.linux_glibc2.5.i386.rpm-bundle(文件夹)
　　jdk-6u45-linux-i586-rpm.bin(文件)&lt;/p&gt;

&lt;p&gt;二、Openjdk卸载&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;　　rpm -qa&lt;/td&gt;
      &lt;td&gt;grep java&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　　rpm -e –nodeps  ***&lt;/p&gt;

&lt;p&gt;三、Jdk安装&lt;/p&gt;

&lt;p&gt;　　(1)修改权限&lt;/p&gt;

&lt;p&gt;　　chmod 755 jdk-6u45-linux-i586-rpm.bin&lt;/p&gt;

&lt;p&gt;　　(2)安装jdk&lt;/p&gt;

&lt;p&gt;　　./jdk-6u45-linux-i586-rpm.bin
  	rpm –ivh jdk-6u45-linux-i586.rpm&lt;/p&gt;

&lt;p&gt;　　(3)修改配置&lt;/p&gt;

&lt;p&gt;　　vi /etc/profile&lt;/p&gt;

&lt;p&gt;　　export JAVA_HOME=/usr/java/ jdk1.6.0_45&lt;/p&gt;

&lt;p&gt;　　export PATH=$PATH:$JAVA_HOME/bin&lt;/p&gt;

&lt;p&gt;　　.  /etc/profile&lt;/p&gt;

&lt;p&gt;　　.和/之间有空格&lt;/p&gt;

&lt;p&gt;四、防火墙设置&lt;/p&gt;

&lt;p&gt;　　Service iptables stop&lt;/p&gt;

&lt;p&gt;五、Tomcat安装&lt;/p&gt;

&lt;p&gt;　　cd /itec/upload&lt;/p&gt;

&lt;p&gt;　　mv apache-tomcat-7.0.68 /itec&lt;/p&gt;

&lt;p&gt;　　cd /itec/apache-tomcat-7.0.68/bin&lt;/p&gt;

&lt;p&gt;　　./startup.sh&lt;/p&gt;

&lt;p&gt;六、Mysql安装&lt;/p&gt;

&lt;p&gt;　　cd /itec/upload/ MySQL-5.6.29-1.linux_glibc2.5.i386.rpm-bundle&lt;/p&gt;

&lt;p&gt;　　(1)安装share&lt;/p&gt;

&lt;p&gt;　　rpm –ivh MySQL-shared-5.6.29-1.linux_glibc2.5.i386.rpm&lt;/p&gt;

&lt;p&gt;　　(2)安装server&lt;/p&gt;

&lt;p&gt;　　rpm –ivh	MySQL-server-5.6.29-1.linux_glibc2.5.i386.rpm&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;　　rpm -qa&lt;/td&gt;
      &lt;td&gt;grep mysql&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　　rpm -ev –nodeps mysql-libs-5.1.66-2.el6_3.i686&lt;/p&gt;

&lt;p&gt;　　(3)安装client&lt;/p&gt;

&lt;p&gt;　　rpm –ivh	MySQL-client-5.6.29-1.linux_glibc2.5.i386.rpm&lt;/p&gt;

&lt;p&gt;　　(4)修改密码&lt;/p&gt;

&lt;p&gt;　　more /root/.mysql_secret
  	service mysql start
  	mysql –uroot –p&lt;/p&gt;

  	set password=password(‘itec_jtwz’);

&lt;p&gt;　　(5)修改访问用户权限&lt;/p&gt;

&lt;p&gt;　　use mysql&lt;/p&gt;

&lt;p&gt;　　select host from user;&lt;/p&gt;

&lt;p&gt;　　delete from user where host=’localhost’;&lt;/p&gt;

&lt;p&gt;　　update user set host=’%’;&lt;/p&gt;

&lt;p&gt;　　flush privileges;&lt;/p&gt;

&lt;p&gt;　　(6)修改utf8编码&lt;/p&gt;

&lt;p&gt;　　show variables like’character%’;&lt;/p&gt;

&lt;p&gt;　　vi /usr	/my.cnf&lt;/p&gt;

&lt;p&gt;　　character-set-server=utf8&lt;/p&gt;

&lt;p&gt;　　lower_case_table_names=1;(让linux下mysql大小写不敏感)&lt;/p&gt;

&lt;p&gt;　　(7) mysqld_safe –skip-grant-tables&lt;/p&gt;

&lt;p&gt;　　 /etc/rc.d/init.d/mysql stop&lt;/p&gt;

&lt;p&gt;　　/etc/rc.d/init.d/mysql start&lt;/p&gt;

&lt;p&gt;　　sudo mysql -uroot –p&lt;/p&gt;

&lt;p&gt;　　(8)删root用户 user&lt;/p&gt;

&lt;p&gt;　　Insert root %,localhost&lt;/p&gt;

&lt;p&gt;　　INSERT INTO &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt; VALUES (‘localhost’,’root’,’’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’’,’’,’’,’‘,0,0,0,0);&lt;/p&gt;

&lt;p&gt;　　INSERT INTO &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt; VALUES (‘%’,’root’,’’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’Y’,’’,’’,’’,’‘,0,0,0,0);&lt;/p&gt;

</description>
        <pubDate>Wed, 13 Mar 2013 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/linux/2013/03/13/LinuxConfig.html</link>
        <guid isPermaLink="true">http://localhost:4000/linux/2013/03/13/LinuxConfig.html</guid>
        
        <category>linux</category>
        
        <category>环境搭建</category>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>Win7上安装Linux双系统</title>
        <description>&lt;h1 id=&quot;一硬盘准备&quot;&gt;一、硬盘准备&lt;/h1&gt;

&lt;p&gt;　　linux对于java程序猿来说是必备技能，为了学习linux，也不可能专门整台电脑，好多人都为了图方便，用vmware做，我感觉的确是太水了，一点没有极客的style，还是做个双系统比较帅气。&lt;/p&gt;

&lt;p&gt;　　首先，我们要准备一个空闲的硬盘空间，我就是用u盘启动盘里面的分区软件，把我常用来下载缓存的50G的F盘给格式化，然后删除了，这样我们就有了50G的空闲存储。不用格式化，不用再分盘符，只要让其实空闲存储空间就行，这里说的空闲存储不是说有个F盘能访问，但是里面什么文件都没有，而是你在往这个区内安装系统之前，根本就没法访问这块区域。&lt;/p&gt;

&lt;h1 id=&quot;二镜像准备&quot;&gt;二、镜像准备&lt;/h1&gt;

&lt;p&gt;　　Centos，Redhat什么的都可以，我用的是Centos7，从官网下载dvd版本，everything版本的太大，内存8G实际只能使用6G多点的U盘装不下，只能下载4G多点的dvd版本。&lt;/p&gt;

&lt;h1 id=&quot;三upan准备&quot;&gt;三、Upan准备&lt;/h1&gt;

&lt;p&gt;　　在上述第一步操作中，准备空闲区域可以用U盘启动制作程序（网上随便搜一个就行）把U盘制作成系统启动U盘，然后重启电脑，进入U盘中的PE系统，里面有个硬盘分区工具，可以帮助你将平时用不着的硬盘分区转换成空闲区域。&lt;/p&gt;

&lt;p&gt;　　在上述两步都做完的前提之下，用UltraISO将linux镜像写入到U盘中，在写入之前请先格式化U盘。&lt;/p&gt;

&lt;h1 id=&quot;四安装centos7&quot;&gt;四、安装Centos7&lt;/h1&gt;
&lt;p&gt;　　使用U盘启动盘之前呢，先进入电脑的bios模式，修改U盘启动在先；当然，你也可以直接在开机时，多次敲击Del键或者F2键，选择从U盘进入系统也行。&lt;/p&gt;

&lt;h3 id=&quot;一装系统&quot;&gt;（一）装系统&lt;/h3&gt;

&lt;p&gt;　　关机，插入U盘，然后开机，选择进入U盘系统，过会会有centos安装界面，第一步是让你选择系统语言，选择中文之后，然后这一步是很多配置项，选择安装位置 处 选择当前空闲的 50G 所在的硬盘选项。&lt;/p&gt;

&lt;h3 id=&quot;二安装软件&quot;&gt;（二）安装软件&lt;/h3&gt;

&lt;p&gt;　　然后选择安装软件，建议你选择最后一个带界面的方便开发用的选项，右边多选除了数据库其他都选上吧。&lt;/p&gt;

&lt;h3 id=&quot;三其他设置&quot;&gt;（三）其他设置&lt;/h3&gt;

&lt;p&gt;　　然后选择网络，直接找个连上就好，然后进入下一步，设置root密码，建议设个简单好记的，要不然很麻烦。然后等待安装结束，估计需要半个小时左右。安装完毕之后，重启电脑，立即拔掉U盘，然后过会就能看到期待已久的Centos图形界面，这样下来系统就安装完毕了。
　　  	
　　&lt;/p&gt;

</description>
        <pubDate>Fri, 01 Mar 2013 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/linux/2013/03/01/LinuxSetUp.html</link>
        <guid isPermaLink="true">http://localhost:4000/linux/2013/03/01/LinuxSetUp.html</guid>
        
        <category>linux</category>
        
        <category>双系统</category>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>关于Java设计模式的肤浅看法--装饰者模式（四）</title>
        <description>&lt;h1 id=&quot;以下内容为观察者模式内容还未修改成装饰者模式敬请期待&quot;&gt;以下内容为观察者模式内容，还未修改成装饰者模式，敬请期待。&lt;/h1&gt;
&lt;h1 id=&quot;一内容概述&quot;&gt;一、内容概述&lt;/h1&gt;

&lt;p&gt;　　观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。&lt;/p&gt;

&lt;p&gt;　　观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。&lt;/p&gt;

&lt;p&gt;　　刚开始会通过气象局模型由浅入深讲一下实际问题的出现，然后举例简述一下观察者模式的使用场景，然后再归纳总结该模式的设计原则，设计思想和组织架构，最后应用此设计模式到气象局项目代码中去。&lt;/p&gt;

&lt;p&gt;　　然后会提出一些气象局项目中出现的弊端，并找出根源所在。&lt;/p&gt;

&lt;p&gt;　　阐述一下java原生对观察者模式的支持。&lt;/p&gt;

&lt;p&gt;　　最后归纳使用该模式的优缺点，以备将来实际开发中发挥其长处，规避其短处。&lt;/p&gt;
&lt;h1 id=&quot;二正文&quot;&gt;二、正文&lt;/h1&gt;

&lt;h3 id=&quot;一气象局模型需求分析&quot;&gt;（一）气象局模型需求分析&lt;/h3&gt;

&lt;h4 id=&quot;1需求抛出&quot;&gt;      1，需求抛出&lt;/h4&gt;

&lt;p&gt;　　气象局想建立一个应用，该应用提供多个布告板，分别显示天气的不同维度的数据，当天气数据更新时，布告板的数据需要实时更新。&lt;/p&gt;
&lt;h4 id=&quot;2需求确定&quot;&gt;      2，需求确定&lt;/h4&gt;

&lt;p&gt;　　气象数据类WeatherData目前有温度，湿度，气压三种测试数据，而 “目前状况”，“气象统计”，“天气预报”三个布告板会在WeatherData数据更新时候即时更新自己的数据显示。此系统必须可扩展，布告板可定制，用户可随意添加或删除布告板。&lt;/p&gt;
&lt;h4 id=&quot;3尝试解决&quot;&gt;      3，尝试解决&lt;/h4&gt;

&lt;p&gt;　　直接在WeatherData类中引入三个布告板的引用，并在数据更新时，直接通过布告板的引用调用其自身更新业务逻辑方法。问题出来了，这种编程实际是针对具体实现编程，而非针对接口编程，耦合度太高；新增或者删除布告板，我们都需要修改代码，侵犯了WeatherData的封装。需要通知的布告板集合实际为动态变化的部分，我们需要将变化的逻辑封装，防止影响不变化的部分。&lt;/p&gt;
&lt;h3 id=&quot;二举例观察者模式的使用&quot;&gt;（二）举例观察者模式的使用&lt;/h3&gt;

&lt;h4 id=&quot;1报纸和杂志订阅&quot;&gt;      1，报纸和杂志订阅&lt;/h4&gt;

&lt;p&gt;　　报社出版报纸或杂志，当用户订阅之后，报社就会一直定期送下去；当用户取消订阅(到期在这里也归纳成取消的一种)，报社就会停止送报。&lt;/p&gt;

&lt;h4 id=&quot;2求职者和猎头&quot;&gt;      2，求职者和猎头&lt;/h4&gt;
&lt;p&gt;　　求职者A告诉猎头B他需要一份工作，猎头B就会将该求职者列入他的客户列表中，并在招聘公司有招聘消息之后，及时推送招聘信息给他客户列表中的所有客户，显然包括A；当A通过猎头或者自己找到工作之后，他就会告诉猎头我找到工作了，不需要再推送消息给他，猎头确认之后就会将A从他的客户列表中删除，在以后的招聘信息推送时，就不会再推送到A那去了。&lt;/p&gt;
&lt;h3 id=&quot;三知识架构&quot;&gt;（三）知识架构&lt;/h3&gt;

&lt;h4 id=&quot;1模式结构&quot;&gt;      1，模式结构&lt;/h4&gt;
&lt;p&gt;　　当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。观察者提供了一种对象设计方式，它让主题和观察者之间松耦合。松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降到了最低。下面就以一个示意性的实现讲解观察者模式的结构。
　　&lt;!-- ![edit](/static/assets/img/blog/java/patterns/3-1.png) --&gt;
	&lt;center&gt;&lt;img src=&quot;/static/assets/img/blog/java/patterns/3-1.png&quot; width=&quot;75%&quot; /&gt;&lt;/center&gt;
　　观察者模式所涉及的角色有：&lt;/p&gt;

&lt;p&gt;　　●  抽象主题(Subject)角色：抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。&lt;/p&gt;

&lt;p&gt;　　●  具体主题(ConcreteSubject)角色：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。&lt;/p&gt;

&lt;p&gt;　　●  抽象观察者(Observer)角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。&lt;/p&gt;

&lt;p&gt;　　●  具体观察者(ConcreteObserver)角色：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态 像协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。&lt;/p&gt;

&lt;p&gt;　　源代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	/**
     * 抽象主题角色类
     */
	public abstract class Subject {
	    /**
	     * 用来保存注册的观察者对象
	     */
	    private	List&amp;lt;Observer&amp;gt; list = new ArrayList&amp;lt;Observer&amp;gt;();
	    /**
	     * 注册观察者对象
	     * @param observer    观察者对象
	     */
	    public void attach(Observer observer){
	        list.add(observer);
	        System.out.println(&quot;Attached an observer&quot;);
	    }
	    /**
	     * 删除观察者对象
	     * @param observer    观察者对象
	     */
	    public void detach(Observer observer){
	        
	        list.remove(observer);
	    }
	    /**
	     * 通知所有注册的观察者对象
	     */
	    public void nodifyObservers(String newState){
	        
	        for(Observer observer : list){
	            observer.update(newState);
	        }
	    }
	}
	/**
     * 具体主题角色类
     */
	public class ConcreteSubject extends Subject{
	    private String state;
	    public String getState() {
	        return state;
	    }
		public void change(String newState){
	        state = newState;
	        System.out.println(&quot;主题状态为：&quot; + state);
	        //状态发生改变，通知各个观察者
	        this.nodifyObservers(state);
	    }
	}
	/**
     * 抽象观察者角色类
     */
	public interface Observer {
	    /**
	     * 更新接口
	     * @param state    更新的状态
	     */
	    public void update(String state);
	}
	/**
     * 具体观察者角色类
     */
	public class ConcreteObserver implements Observer {
	    //观察者的状态
	    private String observerState;
	    @Override
	    public void update(String state) {
	        /**
	         * 更新观察者的状态，使其与目标的状态保持一致
	         */
	        observerState = state;
	        System.out.println(&quot;状态为：&quot;+observerState);
	    }
	
	}
	/**
     * 测试类
     */
	public class Client {
		public static void main(String[] args) {
	        //创建主题对象
	        ConcreteSubject subject = new ConcreteSubject();
	        //创建观察者对象
	        Observer observer = new ConcreteObserver();
	        //将观察者对象登记到主题对象上
	        subject.attach(observer);
	        //改变主题对象的状态
	        subject.change(&quot;new state&quot;);
	    }
	
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;　　在运行时，这个客户端首先创建了具体主题类的实例，以及一个观察者对象。然后，它调用主题对象的attach()方法，将这个观察者对象向主题对象登记，也就是将它加入到主题对象的聚集中去。&lt;/p&gt;

&lt;p&gt;　　这时，客户端调用主题的change()方法，改变了主题对象的内部状态。主题对象在状态发生变化时，调用超类的notifyObservers()方法，通知所有登记过的观察者对象。&lt;/p&gt;
&lt;h4 id=&quot;2使用场景&quot;&gt;      2，使用场景&lt;/h4&gt;

&lt;p&gt;　　假设现在要设计一个贩卖各类书籍的电子商务网站的购物车系统。一个最简单的情况就是把所有货品的单价乘上数量，但是实际情况肯定比这要复杂。比如，本网站可能对所有的高级会员提供每本20%的促销折扣；对中级会员提供每本10%的促销折扣；对初级会员没有折扣。&lt;/p&gt;

&lt;p&gt;　　根据描述，折扣是根据以下的几个算法中的一个进行的：&lt;/p&gt;

&lt;p&gt;　　      算法一：对初级会员没有折扣。&lt;/p&gt;

&lt;p&gt;　　      算法二：对中级会员提供10%的促销折扣。&lt;/p&gt;

&lt;p&gt;　　      算法三：对高级会员提供20%的促销折扣。&lt;/p&gt;

&lt;p&gt;　　使用策略模式来实现的结构图如下：
　　&lt;!-- ![edit](/static/assets/img/blog/java/patterns/price.png) --&gt;
	&lt;center&gt;&lt;img src=&quot;/static/assets/img/blog/java/patterns/price.png&quot; width=&quot;75%&quot; /&gt;&lt;/center&gt;
　　源代码如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	/**
	* 折扣接口
	*/
	public interface MemberStrategy {
	    /**
	     * 计算图书的价格
	     * @param booksPrice    图书的原价
	     * @return    计算出打折后的价格
	     */
	    public double calcPrice(double booksPrice);
	}
	/**
	*初级会员折扣类
	*/
	public class PrimaryMemberStrategy implements MemberStrategy {
	    @Override
	    public double calcPrice(double booksPrice) {
	        System.out.println(&quot;对于初级会员的没有折扣&quot;);
	        return booksPrice;
	    }
	}
	/**
	*中级会员折扣类
	*/
	public class IntermediateMemberStrategy implements MemberStrategy {
	    @Override
	    public double calcPrice(double booksPrice) {
	        System.out.println(&quot;对于中级会员的折扣为10%&quot;);
	        return booksPrice * 0.9;
	    }
	}
	/**
	*高级会员折扣类
	*/
	public class AdvancedMemberStrategy implements MemberStrategy {
	    @Override
	    public double calcPrice(double booksPrice) { 
	        System.out.println(&quot;对于高级会员的折扣为20%&quot;);
	        return booksPrice * 0.8;
	    }
	}
	/**
	*价格类
	*/
	public class Price {
	    //持有一个具体的策略对象
	    private MemberStrategy strategy;
	    /**
	     * 构造函数，传入一个具体的策略对象
	     * @param strategy    具体的策略对象
	     */
	    public Price(MemberStrategy strategy){
	        this.strategy = strategy;
	    }
	    /**
	     * 计算图书的价格
	     * @param booksPrice    图书的原价
	     * @return    计算出打折后的价格
	     */
	    public double quote(double booksPrice){
	        return this.strategy.calcPrice(booksPrice);
	    }
	}
	/**
	* 测试
	*/
	public class Test {
	    public static void main(String[] args) {
	        //选择并创建需要使用的策略对象
	        MemberStrategy strategy = new AdvancedMemberStrategy();
	        //创建环境
	        Price price = new Price(strategy);
	        //计算价格
	        double quote = price.quote(300);
	        System.out.println(&quot;图书的最终价格为：&quot; + quote);
	    }
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;　　从上面的示例可以看出，策略模式仅仅封装算法，提供新的算法插入到已有系统中，以及老算法从系统中“退休”的方法，策略模式并不决定在何时使用何种算法。在什么情况下使用什么算法是由客户端决定的。&lt;/p&gt;
&lt;h3 id=&quot;四气象局项目实现&quot;&gt;（四）气象局项目实现&lt;/h3&gt;
&lt;h4 id=&quot;1编写接口&quot;&gt;      1，编写接口&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	/**
	* 主题接口
	*/
	public interface Subject{
		void registerObserver(Observer o);
		void removeObserver(Observer o);
		void notifyObservers();
	}
	/**
	* 观察者接口
	* 所有观察者都必须实现此接口
	*/
	public interface Observer{
		void registerObserver();
		void removeObserver();
		void update(float temp,float humidity,float pressure);
	}
	/**
	* 主题接口
	*/
	public interface DisplayElement{
		void display();
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2实现主题&quot;&gt;      2，实现主题&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	public class WeatherData implements Subject{
		private ArrayList observers;//已经注册在内的观察者集合
		private float temperature;//温度
		private float humidity;//湿度
		private float pressure;//气压

		public WeatherData(){
			observers = new ArrayList();
		}
		/**
		* 注册观察者实例
		*/
		public void registerObserver(Observer o){
			observers.add(o);
		}
		/**
		* 移除观察者实例
		*/
		public void removeObserver(Observer o){
			int i = observers.indexOf(o);
			if(i &amp;gt;= 0) observers.remove(i);
		}
		/**
		* 向所有已经注册的观察者实例发送消息
		*/
		public void notifyObservers(){
			for(Observer o:observers){
				o.update(temperature,humidity,pressure);
			}
		}
		/**
		* 气象数据更新时调用的方法
		*/
		public void measurementsChanged(){
			notifyObservers();
		}
		/**
		* 改动气象数据，方便测试用
		*/
		public void setMeasurements(float temperature,float humidity,float pressure){
			this.temperature = temperature;
			this.humidity = humidity;
			this.pressure = pressure;
			measurementsChanged();
		}
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;3实现观察者这里只写其中一个布告板&quot;&gt;      3，实现观察者(这里只写其中一个布告板)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	/**
	* 目前状况布告板 实现
	*/
	public class CurrentConditionsDisplay implements Observer,DisplayElement{
		private float temperature;
		private float humidity;
		private Subject weatherData;

		public CurrentConditionsDisplay(Subject weatherData){
			this.weatherData = weatherData;
			registerObserver();
		}
		publid void registerObserver(){
			weatherData.registerObserver(this);
		}
		public void removeObserver(){
			weatherData.removeObserver(this);
		}
		/**
		* 观察者被通知时调用的方法
		*/
		public void update(float temperature,float humidity,float pressure){
			this.temperature = temperature;
			this.humidity = humidity;
			display();
		}
		/**
		* 显示数据
		*/
		public void display(){
			System.out.println(&quot;Current conditions:&quot;+temperature+
				&quot;F degress and &quot;+ humidity +&quot;% humidity&quot;);
		}
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;4测试&quot;&gt;      4，测试&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	public class Test(){
		public static void main(String args[]){
			WeatherData weatherData = new WeatherData();
			CurrentConditionsDisplay currentDisplay = 
				new CurrentConditionsDisplay(weatherData);
			weatherData.setMeasurements(80,65,30.4f);
			weatherData.setMeasurements(81,63,31.4f);
			weatherData.setMeasurements(82,64,32.4f);
		}
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;五推模型and拉模型&quot;&gt;（五）推模型And拉模型&lt;/h3&gt;

&lt;p&gt;　　在上一小节气象局项目中，我们注意到，观察者只能被动的接受数据，可能有些数据并不是它想要的，比如CurrentConditionsDisplay这个类中，它只关心当前温度和湿度，不关心气压，但是update方法不得不接受这个参数，因为update方法是在观察者统一接口中定义的，不允许改变（当然可以在接口中实现重载方法，但是还是感觉不大妥当），所以是不是需要让观察者可以主动获取它想要的数据信息，这样代码更优雅一些。而这个问题正是我们接下来要讨论的两种模型，推模型和拉模型。&lt;/p&gt;

&lt;p&gt;　　●  推模型&lt;/p&gt;

&lt;p&gt;　　主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。&lt;/p&gt;

&lt;p&gt;　　●  拉模型&lt;/p&gt;

&lt;p&gt;　　主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。&lt;/p&gt;

&lt;p&gt;　　根据上面的描述，发现气象局项目的例子就是典型的推模型，下面给出一个拉模型的实例。&lt;/p&gt;

&lt;h4 id=&quot;1拉模型的抽象观察者类&quot;&gt;      1，拉模型的抽象观察者类&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	public interface Observer {
	    /**
	     * 更新接口
	     * @param subject 传入主题对象，方面获取相应的主题对象的状态
	     */
	    public void update(Subject subject);
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2拉模型的具体观察者类&quot;&gt;      2，拉模型的具体观察者类&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	public class ConcreteObserver implements Observer {
	    //观察者的状态
	    private String observerState;
	    @Override
	    public void update(Subject subject) {
	        /**
	         * 更新观察者的状态，使其与目标的状态保持一致
	         */
	        observerState = ((ConcreteSubject)subject).getState();
	        System.out.println(&quot;观察者状态为：&quot;+observerState);
	    }
	
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;3拉模型的抽象主题类&quot;&gt;      3，拉模型的抽象主题类&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	public abstract class Subject {
	    /**
	     * 用来保存注册的观察者对象
	     */
	    private List&amp;lt;Observer&amp;gt; list = new ArrayList&amp;lt;Observer&amp;gt;();
	    /**
	     * 注册观察者对象
	     * @param observer    观察者对象
	     */
	    public void attach(Observer observer){
	        list.add(observer);
	        System.out.println(&quot;Attached an observer&quot;);
	    }
	    /**
	     * 删除观察者对象
	     * @param observer    观察者对象
	     */
	    public void detach(Observer observer){
	        list.remove(observer);
	    }
	    /**
	     * 通知所有注册的观察者对象
	     */
	    public void nodifyObservers(){
	        for(Observer observer : list){
	            observer.update(this);
	        }
	    }
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;4拉模型的具体主题类&quot;&gt;      4，拉模型的具体主题类&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	public class ConcreteSubject extends Subject{
	    private String state;
	    public String getState() {
	        return state;
	    }
	    public void change(String newState){
	        state = newState;
	        System.out.println(&quot;主题状态为：&quot; + state);
	        //状态发生改变，通知各个观察者
	        this.nodifyObservers();
	    }
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;5两种模式的比较&quot;&gt;      5，两种模式的比较&lt;/h4&gt;
&lt;p&gt;　　■　　推模型是假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。&lt;/p&gt;

&lt;p&gt;　　■　　推模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。&lt;/p&gt;
&lt;h3 id=&quot;六java内置观察者模式&quot;&gt;（六）Java内置观察者模式&lt;/h3&gt;

&lt;p&gt;　　java内置的观察者模式有以下缺点：&lt;/p&gt;

&lt;p&gt;　　■　　Observable（主题）是一个类，而不是接口，因为java不能实现多继承，假如有一个类需要同时具有Observable类和另外一个超类的行为，那就不好办了。&lt;/p&gt;

&lt;h1 id=&quot;三引用&quot;&gt;三、引用&lt;/h1&gt;

&lt;p&gt;　　《Head First 设计模式》&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;http://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html&quot;&gt;《JAVA与模式》之装饰者模式&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;/java/2012/04/03/ObserverPattern.html&quot;&gt;关于Java设计模式的肤浅看法–观察者模式（三）&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;四结束语&quot;&gt;四、结束语&lt;/h1&gt;
&lt;p&gt;　　据笔者了解，MQ消息队列分点对点和订阅发布两种模式，而订阅发布就是利用的观察者模式的思想。&lt;/p&gt;

&lt;p&gt;　　&lt;/p&gt;

</description>
        <pubDate>Wed, 04 Apr 2012 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2012/04/04/DecoratorPattern.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2012/04/04/DecoratorPattern.html</guid>
        
        <category>java</category>
        
        <category>装饰者模式</category>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>关于Java设计模式的肤浅看法--观察者模式（三）</title>
        <description>&lt;h1 id=&quot;一内容概述&quot;&gt;一、内容概述&lt;/h1&gt;

&lt;p&gt;　　观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。&lt;/p&gt;

&lt;p&gt;　　观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。&lt;/p&gt;

&lt;p&gt;　　刚开始会通过气象局模型由浅入深讲一下实际问题的出现，然后举例简述一下观察者模式的使用场景，然后再归纳总结该模式的设计原则，设计思想和组织架构，最后应用此设计模式到气象局项目代码中去。&lt;/p&gt;

&lt;p&gt;　　然后会提出一些气象局项目中出现的弊端，并找出根源所在。&lt;/p&gt;

&lt;p&gt;　　阐述一下java原生对观察者模式的支持。&lt;/p&gt;

&lt;p&gt;　　最后归纳使用该模式的优缺点，以备将来实际开发中发挥其长处，规避其短处。&lt;/p&gt;
&lt;h1 id=&quot;二正文&quot;&gt;二、正文&lt;/h1&gt;

&lt;h3 id=&quot;一气象局模型需求分析&quot;&gt;（一）气象局模型需求分析&lt;/h3&gt;

&lt;h4 id=&quot;1需求抛出&quot;&gt;      1，需求抛出&lt;/h4&gt;

&lt;p&gt;　　气象局想建立一个应用，该应用提供多个布告板，分别显示天气的不同维度的数据，当天气数据更新时，布告板的数据需要实时更新。&lt;/p&gt;
&lt;h4 id=&quot;2需求确定&quot;&gt;      2，需求确定&lt;/h4&gt;

&lt;p&gt;　　气象数据类WeatherData目前有温度，湿度，气压三种测试数据，而 “目前状况”，“气象统计”，“天气预报”三个布告板会在WeatherData数据更新时候即时更新自己的数据显示。此系统必须可扩展，布告板可定制，用户可随意添加或删除布告板。&lt;/p&gt;
&lt;h4 id=&quot;3尝试解决&quot;&gt;      3，尝试解决&lt;/h4&gt;

&lt;p&gt;　　直接在WeatherData类中引入三个布告板的引用，并在数据更新时，直接通过布告板的引用调用其自身更新业务逻辑方法。问题出来了，这种编程实际是针对具体实现编程，而非针对接口编程，耦合度太高；新增或者删除布告板，我们都需要修改代码，侵犯了WeatherData的封装。需要通知的布告板集合实际为动态变化的部分，我们需要将变化的逻辑封装，防止影响不变化的部分。&lt;/p&gt;
&lt;h3 id=&quot;二举例观察者模式的使用&quot;&gt;（二）举例观察者模式的使用&lt;/h3&gt;

&lt;h4 id=&quot;1报纸和杂志订阅&quot;&gt;      1，报纸和杂志订阅&lt;/h4&gt;

&lt;p&gt;　　报社出版报纸或杂志，当用户订阅之后，报社就会一直定期送下去；当用户取消订阅(到期在这里也归纳成取消的一种)，报社就会停止送报。&lt;/p&gt;

&lt;h4 id=&quot;2求职者和猎头&quot;&gt;      2，求职者和猎头&lt;/h4&gt;
&lt;p&gt;　　求职者A告诉猎头B他需要一份工作，猎头B就会将该求职者列入他的客户列表中，并在招聘公司有招聘消息之后，及时推送招聘信息给他客户列表中的所有客户，显然包括A；当A通过猎头或者自己找到工作之后，他就会告诉猎头我找到工作了，不需要再推送消息给他，猎头确认之后就会将A从他的客户列表中删除，在以后的招聘信息推送时，就不会再推送到A那去了。&lt;/p&gt;
&lt;h3 id=&quot;三知识架构&quot;&gt;（三）知识架构&lt;/h3&gt;

&lt;h4 id=&quot;1模式结构&quot;&gt;      1，模式结构&lt;/h4&gt;
&lt;p&gt;　　当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。观察者提供了一种对象设计方式，它让主题和观察者之间松耦合。松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降到了最低。下面就以一个示意性的实现讲解观察者模式的结构。
　　&lt;!-- ![edit](/static/assets/img/blog/java/patterns/3-1.png) --&gt;
	&lt;center&gt;&lt;img src=&quot;/static/assets/img/blog/java/patterns/3-1.png&quot; width=&quot;75%&quot; /&gt;&lt;/center&gt;
　　观察者模式所涉及的角色有：&lt;/p&gt;

&lt;p&gt;　　●  抽象主题(Subject)角色：抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。&lt;/p&gt;

&lt;p&gt;　　●  具体主题(ConcreteSubject)角色：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。&lt;/p&gt;

&lt;p&gt;　　●  抽象观察者(Observer)角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。&lt;/p&gt;

&lt;p&gt;　　●  具体观察者(ConcreteObserver)角色：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态 像协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。&lt;/p&gt;

&lt;p&gt;　　源代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	/**
     * 抽象主题角色类
     */
	public abstract class Subject {
	    /**
	     * 用来保存注册的观察者对象
	     */
	    private	List&amp;lt;Observer&amp;gt; list = new ArrayList&amp;lt;Observer&amp;gt;();
	    /**
	     * 注册观察者对象
	     * @param observer    观察者对象
	     */
	    public void attach(Observer observer){
	        list.add(observer);
	        System.out.println(&quot;Attached an observer&quot;);
	    }
	    /**
	     * 删除观察者对象
	     * @param observer    观察者对象
	     */
	    public void detach(Observer observer){
	        
	        list.remove(observer);
	    }
	    /**
	     * 通知所有注册的观察者对象
	     */
	    public void nodifyObservers(String newState){
	        
	        for(Observer observer : list){
	            observer.update(newState);
	        }
	    }
	}
	/**
     * 具体主题角色类
     */
	public class ConcreteSubject extends Subject{
	    private String state;
	    public String getState() {
	        return state;
	    }
		public void change(String newState){
	        state = newState;
	        System.out.println(&quot;主题状态为：&quot; + state);
	        //状态发生改变，通知各个观察者
	        this.nodifyObservers(state);
	    }
	}
	/**
     * 抽象观察者角色类
     */
	public interface Observer {
	    /**
	     * 更新接口
	     * @param state    更新的状态
	     */
	    public void update(String state);
	}
	/**
     * 具体观察者角色类
     */
	public class ConcreteObserver implements Observer {
	    //观察者的状态
	    private String observerState;
	    @Override
	    public void update(String state) {
	        /**
	         * 更新观察者的状态，使其与目标的状态保持一致
	         */
	        observerState = state;
	        System.out.println(&quot;状态为：&quot;+observerState);
	    }
	
	}
	/**
     * 测试类
     */
	public class Client {
		public static void main(String[] args) {
	        //创建主题对象
	        ConcreteSubject subject = new ConcreteSubject();
	        //创建观察者对象
	        Observer observer = new ConcreteObserver();
	        //将观察者对象登记到主题对象上
	        subject.attach(observer);
	        //改变主题对象的状态
	        subject.change(&quot;new state&quot;);
	    }
	
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;　　在运行时，这个客户端首先创建了具体主题类的实例，以及一个观察者对象。然后，它调用主题对象的attach()方法，将这个观察者对象向主题对象登记，也就是将它加入到主题对象的聚集中去。&lt;/p&gt;

&lt;p&gt;　　这时，客户端调用主题的change()方法，改变了主题对象的内部状态。主题对象在状态发生变化时，调用超类的notifyObservers()方法，通知所有登记过的观察者对象。&lt;/p&gt;
&lt;h4 id=&quot;2使用场景&quot;&gt;      2，使用场景&lt;/h4&gt;

&lt;p&gt;　　假设现在要设计一个贩卖各类书籍的电子商务网站的购物车系统。一个最简单的情况就是把所有货品的单价乘上数量，但是实际情况肯定比这要复杂。比如，本网站可能对所有的高级会员提供每本20%的促销折扣；对中级会员提供每本10%的促销折扣；对初级会员没有折扣。&lt;/p&gt;

&lt;p&gt;　　根据描述，折扣是根据以下的几个算法中的一个进行的：&lt;/p&gt;

&lt;p&gt;　　      算法一：对初级会员没有折扣。&lt;/p&gt;

&lt;p&gt;　　      算法二：对中级会员提供10%的促销折扣。&lt;/p&gt;

&lt;p&gt;　　      算法三：对高级会员提供20%的促销折扣。&lt;/p&gt;

&lt;p&gt;　　使用策略模式来实现的结构图如下：
　　&lt;!-- ![edit](/static/assets/img/blog/java/patterns/price.png) --&gt;
	&lt;center&gt;&lt;img src=&quot;/static/assets/img/blog/java/patterns/price.png&quot; width=&quot;75%&quot; /&gt;&lt;/center&gt;
　　源代码如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	/**
	* 折扣接口
	*/
	public interface MemberStrategy {
	    /**
	     * 计算图书的价格
	     * @param booksPrice    图书的原价
	     * @return    计算出打折后的价格
	     */
	    public double calcPrice(double booksPrice);
	}
	/**
	*初级会员折扣类
	*/
	public class PrimaryMemberStrategy implements MemberStrategy {
	    @Override
	    public double calcPrice(double booksPrice) {
	        System.out.println(&quot;对于初级会员的没有折扣&quot;);
	        return booksPrice;
	    }
	}
	/**
	*中级会员折扣类
	*/
	public class IntermediateMemberStrategy implements MemberStrategy {
	    @Override
	    public double calcPrice(double booksPrice) {
	        System.out.println(&quot;对于中级会员的折扣为10%&quot;);
	        return booksPrice * 0.9;
	    }
	}
	/**
	*高级会员折扣类
	*/
	public class AdvancedMemberStrategy implements MemberStrategy {
	    @Override
	    public double calcPrice(double booksPrice) { 
	        System.out.println(&quot;对于高级会员的折扣为20%&quot;);
	        return booksPrice * 0.8;
	    }
	}
	/**
	*价格类
	*/
	public class Price {
	    //持有一个具体的策略对象
	    private MemberStrategy strategy;
	    /**
	     * 构造函数，传入一个具体的策略对象
	     * @param strategy    具体的策略对象
	     */
	    public Price(MemberStrategy strategy){
	        this.strategy = strategy;
	    }
	    /**
	     * 计算图书的价格
	     * @param booksPrice    图书的原价
	     * @return    计算出打折后的价格
	     */
	    public double quote(double booksPrice){
	        return this.strategy.calcPrice(booksPrice);
	    }
	}
	/**
	* 测试
	*/
	public class Test {
	    public static void main(String[] args) {
	        //选择并创建需要使用的策略对象
	        MemberStrategy strategy = new AdvancedMemberStrategy();
	        //创建环境
	        Price price = new Price(strategy);
	        //计算价格
	        double quote = price.quote(300);
	        System.out.println(&quot;图书的最终价格为：&quot; + quote);
	    }
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;　　从上面的示例可以看出，策略模式仅仅封装算法，提供新的算法插入到已有系统中，以及老算法从系统中“退休”的方法，策略模式并不决定在何时使用何种算法。在什么情况下使用什么算法是由客户端决定的。&lt;/p&gt;
&lt;h3 id=&quot;四气象局项目实现&quot;&gt;（四）气象局项目实现&lt;/h3&gt;
&lt;h4 id=&quot;1编写接口&quot;&gt;      1，编写接口&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	/**
	* 主题接口
	*/
	public interface Subject{
		void registerObserver(Observer o);
		void removeObserver(Observer o);
		void notifyObservers();
	}
	/**
	* 观察者接口
	* 所有观察者都必须实现此接口
	*/
	public interface Observer{
		void registerObserver();
		void removeObserver();
		void update(float temp,float humidity,float pressure);
	}
	/**
	* 主题接口
	*/
	public interface DisplayElement{
		void display();
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2实现主题&quot;&gt;      2，实现主题&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	public class WeatherData implements Subject{
		private ArrayList observers;//已经注册在内的观察者集合
		private float temperature;//温度
		private float humidity;//湿度
		private float pressure;//气压

		public WeatherData(){
			observers = new ArrayList();
		}
		/**
		* 注册观察者实例
		*/
		public void registerObserver(Observer o){
			observers.add(o);
		}
		/**
		* 移除观察者实例
		*/
		public void removeObserver(Observer o){
			int i = observers.indexOf(o);
			if(i &amp;gt;= 0) observers.remove(i);
		}
		/**
		* 向所有已经注册的观察者实例发送消息
		*/
		public void notifyObservers(){
			for(Observer o:observers){
				o.update(temperature,humidity,pressure);
			}
		}
		/**
		* 气象数据更新时调用的方法
		*/
		public void measurementsChanged(){
			notifyObservers();
		}
		/**
		* 改动气象数据，方便测试用
		*/
		public void setMeasurements(float temperature,float humidity,float pressure){
			this.temperature = temperature;
			this.humidity = humidity;
			this.pressure = pressure;
			measurementsChanged();
		}
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;3实现观察者这里只写其中一个布告板&quot;&gt;      3，实现观察者(这里只写其中一个布告板)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	/**
	* 目前状况布告板 实现
	*/
	public class CurrentConditionsDisplay implements Observer,DisplayElement{
		private float temperature;
		private float humidity;
		private Subject weatherData;

		public CurrentConditionsDisplay(Subject weatherData){
			this.weatherData = weatherData;
			registerObserver();
		}
		publid void registerObserver(){
			weatherData.registerObserver(this);
		}
		public void removeObserver(){
			weatherData.removeObserver(this);
		}
		/**
		* 观察者被通知时调用的方法
		*/
		public void update(float temperature,float humidity,float pressure){
			this.temperature = temperature;
			this.humidity = humidity;
			display();
		}
		/**
		* 显示数据
		*/
		public void display(){
			System.out.println(&quot;Current conditions:&quot;+temperature+
				&quot;F degress and &quot;+ humidity +&quot;% humidity&quot;);
		}
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;4测试&quot;&gt;      4，测试&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	public class Test(){
		public static void main(String args[]){
			WeatherData weatherData = new WeatherData();
			CurrentConditionsDisplay currentDisplay = 
				new CurrentConditionsDisplay(weatherData);
			weatherData.setMeasurements(80,65,30.4f);
			weatherData.setMeasurements(81,63,31.4f);
			weatherData.setMeasurements(82,64,32.4f);
		}
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;五推模型and拉模型&quot;&gt;（五）推模型And拉模型&lt;/h3&gt;

&lt;p&gt;　　在上一小节气象局项目中，我们注意到，观察者只能被动的接受数据，可能有些数据并不是它想要的，比如CurrentConditionsDisplay这个类中，它只关心当前温度和湿度，不关心气压，但是update方法不得不接受这个参数，因为update方法是在观察者统一接口中定义的，不允许改变（当然可以在接口中实现重载方法，但是还是感觉不大妥当），所以是不是需要让观察者可以主动获取它想要的数据信息，这样代码更优雅一些。而这个问题正是我们接下来要讨论的两种模型，推模型和拉模型。&lt;/p&gt;

&lt;p&gt;　　●  推模型&lt;/p&gt;

&lt;p&gt;　　主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。&lt;/p&gt;

&lt;p&gt;　　●  拉模型&lt;/p&gt;

&lt;p&gt;　　主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。&lt;/p&gt;

&lt;p&gt;　　根据上面的描述，发现气象局项目的例子就是典型的推模型，下面给出一个拉模型的实例。&lt;/p&gt;

&lt;h4 id=&quot;1拉模型的抽象观察者类&quot;&gt;      1，拉模型的抽象观察者类&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	public interface Observer {
	    /**
	     * 更新接口
	     * @param subject 传入主题对象，方面获取相应的主题对象的状态
	     */
	    public void update(Subject subject);
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2拉模型的具体观察者类&quot;&gt;      2，拉模型的具体观察者类&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	public class ConcreteObserver implements Observer {
	    //观察者的状态
	    private String observerState;
	    @Override
	    public void update(Subject subject) {
	        /**
	         * 更新观察者的状态，使其与目标的状态保持一致
	         */
	        observerState = ((ConcreteSubject)subject).getState();
	        System.out.println(&quot;观察者状态为：&quot;+observerState);
	    }
	
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;3拉模型的抽象主题类&quot;&gt;      3，拉模型的抽象主题类&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	public abstract class Subject {
	    /**
	     * 用来保存注册的观察者对象
	     */
	    private List&amp;lt;Observer&amp;gt; list = new ArrayList&amp;lt;Observer&amp;gt;();
	    /**
	     * 注册观察者对象
	     * @param observer    观察者对象
	     */
	    public void attach(Observer observer){
	        list.add(observer);
	        System.out.println(&quot;Attached an observer&quot;);
	    }
	    /**
	     * 删除观察者对象
	     * @param observer    观察者对象
	     */
	    public void detach(Observer observer){
	        list.remove(observer);
	    }
	    /**
	     * 通知所有注册的观察者对象
	     */
	    public void nodifyObservers(){
	        for(Observer observer : list){
	            observer.update(this);
	        }
	    }
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;4拉模型的具体主题类&quot;&gt;      4，拉模型的具体主题类&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	public class ConcreteSubject extends Subject{
	    private String state;
	    public String getState() {
	        return state;
	    }
	    public void change(String newState){
	        state = newState;
	        System.out.println(&quot;主题状态为：&quot; + state);
	        //状态发生改变，通知各个观察者
	        this.nodifyObservers();
	    }
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;5两种模式的比较&quot;&gt;      5，两种模式的比较&lt;/h4&gt;
&lt;p&gt;　　■　　推模型是假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。&lt;/p&gt;

&lt;p&gt;　　■　　推模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。&lt;/p&gt;
&lt;h3 id=&quot;六java内置观察者模式&quot;&gt;（六）Java内置观察者模式&lt;/h3&gt;

&lt;p&gt;　　java内置的观察者模式有以下缺点：&lt;/p&gt;

&lt;p&gt;　　■　　Observable（主题）是一个类，而不是接口，因为java不能实现多继承，假如有一个类需要同时具有Observable类和另外一个超类的行为，那就不好办了。&lt;/p&gt;

&lt;h1 id=&quot;三引用&quot;&gt;三、引用&lt;/h1&gt;

&lt;p&gt;　　《Head First 设计模式》&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;http://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html&quot;&gt;《JAVA与模式》之策略模式&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;/java/2012/04/02/StrategyPattern.html&quot;&gt;关于Java设计模式的肤浅看法–策略模式（二）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;/java/2012/04/04/DecoratorPattern.html&quot;&gt;关于Java设计模式的肤浅看法–装饰者模式（四）&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;四结束语&quot;&gt;四、结束语&lt;/h1&gt;
&lt;p&gt;　　据笔者了解，MQ消息队列分点对点和订阅发布两种模式，而订阅发布就是利用的观察者模式的思想。&lt;/p&gt;

&lt;p&gt;　　&lt;/p&gt;

</description>
        <pubDate>Tue, 03 Apr 2012 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2012/04/03/ObserverPattern.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2012/04/03/ObserverPattern.html</guid>
        
        <category>java</category>
        
        <category>观察者模式</category>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>关于Java设计模式的肤浅看法--策略模式（二）</title>
        <description>&lt;h1 id=&quot;一内容概述&quot;&gt;一、内容概述&lt;/h1&gt;

&lt;p&gt;　　策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。&lt;/p&gt;

&lt;p&gt;　　abc&lt;/p&gt;

&lt;p&gt;　　abc&lt;/p&gt;

&lt;p&gt;　　刚开始会通过鸭子模型由浅入深讲一下实际问题的出现和寻找解决方法，然后将解决方法归纳形成最终的设计模式–策略模式。&lt;/p&gt;

&lt;p&gt;　　然后会再次抽象，引用策略模式比较官方的知识点，归纳总结策略模式（在和别人讨论的时候，你总不能和人上来就讲小鸭子的故事吧）。&lt;/p&gt;

&lt;p&gt;　　最后升华一下，再次赘述一下 其中使用到的 设计规则 和 设计思想。&lt;/p&gt;
&lt;h1 id=&quot;二正文&quot;&gt;二、正文&lt;/h1&gt;

&lt;h3 id=&quot;一鸭子模型&quot;&gt;（一）鸭子模型&lt;/h3&gt;

&lt;h4 id=&quot;1问题抛出&quot;&gt;      1，问题抛出&lt;/h4&gt;

&lt;p&gt;　　某公司设计的鸭子游戏，鸭子有呱呱叫，游泳，展示三种行为，但是现在想加入飞行的行为，该怎么设计程序。&lt;/p&gt;
&lt;h4 id=&quot;2尝试解决方法1&quot;&gt;      2，尝试解决方法1&lt;/h4&gt;

&lt;p&gt;　　直接在Duck父类上加入fly()方法，但问题出来了，所有继承改父类的鸭子都会飞了，包括游戏中的橡皮鸭子，这显然是不符合实际情况的。根源在于，为了复用而使用了继承，但没有屏蔽掉继承的缺点。&lt;/p&gt;
&lt;h4 id=&quot;3尝试解决方法2&quot;&gt;      3，尝试解决方法2&lt;/h4&gt;

&lt;p&gt;　　继承不可以，那就用接口，让实现类去实现接口的fly()方法，但是这样下来会出现这种情况，10种鸭子中，有6种是会飞的，那这6种是否都要重新实现的飞行逻辑，也就是说飞行逻辑的代码被重复写了5次，以后要是维护飞行代码，就需要维护6个地方，这显然是一种噩梦。&lt;/p&gt;
&lt;h4 id=&quot;4思路整理&quot;&gt;      4，思路整理&lt;/h4&gt;

&lt;p&gt;　　在之前的尝试解决中，继承不能以直接继承Duck父类的方式使用，接口又不具备实现代码，让每个子类都实现一遍代码编写和后期维护都是问题。&lt;/p&gt;

&lt;p&gt;　　那可不可以把飞行这个行为，有些鸭子具备，有些鸭子不具备的可变的行为独立出来，让会飞的鸭子拿来用，不会的就不用。这样解耦出来，以后也方便对飞行行为的改动和扩展（这样只改动一处代码就好）。&lt;/p&gt;

&lt;p&gt;　　上段文字则是某项设计原则的实际体现：找出应用中可能需要变化之处“封装”起来，以防止可变动的逻辑会影响到不需要变动的逻辑。&lt;/p&gt;

&lt;p&gt;　　另外，针对接口编程也是很重要的设计原则，鸭子的子类使用接口表示的行为，而不是直接将改行为写死在子类代码中，这样会比较灵活。&lt;/p&gt;

&lt;p&gt;　　增加飞行和呱呱叫两个接口只是开始，在以后的游戏升级中，鸭子会增加更多的行为，而按照这种思路去设计，则在增加新功能的同事，又不会影响原来的业务逻辑。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	abc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;5代码实现&quot;&gt;      5，代码实现&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	//鸭子父类
	public class Duck {
	    protected FlyBehavior flyBehavior;
	    protected QuackBehavior quackBehavior;
	
	    //两个Setter方式是用来动态设定行为用的
	    public void setFlyBehavior(FlyBehavior flyBehavior) {
	        this.flyBehavior = flyBehavior;
	    }
	    public void setQuackBehavior(QuackBehavior quackBehavior) {
	        this.quackBehavior = quackBehavior;
	    }

	    //用perform***方法包装一下，是为了让父类代理属性对象的行为，
	    // 其实这里就是代理模式的使用，以后再细说
	    public void performFly(){
	        flyBehavior.fly();
	    }
	    public void performQuack(){
	        quackBehavior.quack();
	    }
	    //不同的鸭子有不同的游泳特点和外观表现形式，这两个方法由子类重写实现
	    public void swim(){}
	    public void display(){}
	}
	//飞行接口
	public interface FlyBehavior {
	    void fly();
	}
	public class FlyWithWings implements FlyBehavior{
	    @Override
	    public void fly() {
	        System.out.println(&quot;I'm flying&quot;);
    	}
	}
	//呱呱叫接口
	public interface QuackBehavior {
	    void quack();
	}
	public class Quack implements QuackBehavior{
	    @Override
	    public void quack() {
	        System.out.println(&quot;呱呱叫&quot;);
	    }
	}
	//绿头鸭具体实现
	public class MallardDuck extends Duck{
	    public MallardDuck(){
	        quackBehavior = new Quack();
	        flyBehavior = new FlyWithWings();
	    }
	    @Override
	    public void display() {
	        System.out.println(&quot;I'm a real Mallard Duck !&quot;);
	    }
	}
	//测试方法
	public class MainActivity {
	    public static void main(String[] args) {
	        Duck duck = new MallardDuck();
	        duck.performFly();
	        duck.performQuack();
	        duck.display();
	    }
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;二设计规格和设计思想&quot;&gt;（二）设计规格和设计思想&lt;/h3&gt;

&lt;p&gt;　　将鸭子的飞行行为或者呱呱叫行为看成是一组算法。&lt;/p&gt;

&lt;p&gt;　　鸭子的飞行行为和呱呱叫行为被Duck组合成两个属性，从而Duck以及其子类也就都拥有了飞行行为和呱呱叫行为，这里遵循的设计规则则是 多用组合，少用继承。&lt;/p&gt;
&lt;h3 id=&quot;三知识架构&quot;&gt;（三）知识架构&lt;/h3&gt;

&lt;h4 id=&quot;1模式结构&quot;&gt;      1，模式结构&lt;/h4&gt;
&lt;p&gt;　　策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。下面就以一个示意性的实现讲解策略模式实例的结构。
　　&lt;!-- ![edit](/static/assets/img/blog/java/patterns/StrategyPattern.png) --&gt;
	&lt;center&gt;&lt;img src=&quot;/static/assets/img/blog/java/patterns/StrategyPattern.png&quot; width=&quot;75%&quot; /&gt;&lt;/center&gt;
　　这个模式涉及到三个角色：&lt;/p&gt;

&lt;p&gt;　　●  环境(Context)角色：持有一个Strategy的引用。&lt;/p&gt;

&lt;p&gt;　　●  抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。&lt;/p&gt;

&lt;p&gt;　　●  具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	public class Context {
	    //持有一个具体策略的对象
	    private Strategy strategy;
	    /**
	     * 构造函数，传入一个具体策略对象
	     * @param strategy    具体策略对象
	     */
	    public Context(Strategy strategy){
	        this.strategy = strategy;
	    }
	    /**
	     * 策略方法
	     */
	    public void contextInterface(){
	        
	        strategy.strategyInterface();
	    }
	}

	public interface Strategy {
	    /**
	     * 策略方法
	     */
	    public void strategyInterface();
	}
	public class ConcreteStrategyA implements Strategy {
	    @Override
	    public void strategyInterface() {
	        //相关的业务
	    }
	}
	public class ConcreteStrategyB implements Strategy {
	    @Override
	    public void strategyInterface() {
	        //相关的业务
	    }
	}
	public class ConcreteStrategyC implements Strategy {
	    @Override
	    public void strategyInterface() {
	        //相关的业务
	    }
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2使用场景&quot;&gt;      2，使用场景&lt;/h4&gt;

&lt;p&gt;　　假设现在要设计一个贩卖各类书籍的电子商务网站的购物车系统。一个最简单的情况就是把所有货品的单价乘上数量，但是实际情况肯定比这要复杂。比如，本网站可能对所有的高级会员提供每本20%的促销折扣；对中级会员提供每本10%的促销折扣；对初级会员没有折扣。&lt;/p&gt;

&lt;p&gt;　　根据描述，折扣是根据以下的几个算法中的一个进行的：&lt;/p&gt;

&lt;p&gt;　　      算法一：对初级会员没有折扣。&lt;/p&gt;

&lt;p&gt;　　      算法二：对中级会员提供10%的促销折扣。&lt;/p&gt;

&lt;p&gt;　　      算法三：对高级会员提供20%的促销折扣。&lt;/p&gt;

&lt;p&gt;　　使用策略模式来实现的结构图如下：
　　&lt;!-- ![edit](/static/assets/img/blog/java/patterns/price.png) --&gt;
	&lt;center&gt;&lt;img src=&quot;/static/assets/img/blog/java/patterns/price.png&quot; width=&quot;75%&quot; /&gt;&lt;/center&gt;
　　源代码如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	/**
	* 折扣接口
	*/
	public interface MemberStrategy {
	    /**
	     * 计算图书的价格
	     * @param booksPrice    图书的原价
	     * @return    计算出打折后的价格
	     */
	    public double calcPrice(double booksPrice);
	}
	/**
	*初级会员折扣类
	*/
	public class PrimaryMemberStrategy implements MemberStrategy {
	    @Override
	    public double calcPrice(double booksPrice) {
	        System.out.println(&quot;对于初级会员的没有折扣&quot;);
	        return booksPrice;
	    }
	}
	/**
	*中级会员折扣类
	*/
	public class IntermediateMemberStrategy implements MemberStrategy {
	    @Override
	    public double calcPrice(double booksPrice) {
	        System.out.println(&quot;对于中级会员的折扣为10%&quot;);
	        return booksPrice * 0.9;
	    }
	}
	/**
	*高级会员折扣类
	*/
	public class AdvancedMemberStrategy implements MemberStrategy {
	    @Override
	    public double calcPrice(double booksPrice) { 
	        System.out.println(&quot;对于高级会员的折扣为20%&quot;);
	        return booksPrice * 0.8;
	    }
	}
	/**
	*价格类
	*/
	public class Price {
	    //持有一个具体的策略对象
	    private MemberStrategy strategy;
	    /**
	     * 构造函数，传入一个具体的策略对象
	     * @param strategy    具体的策略对象
	     */
	    public Price(MemberStrategy strategy){
	        this.strategy = strategy;
	    }
	    /**
	     * 计算图书的价格
	     * @param booksPrice    图书的原价
	     * @return    计算出打折后的价格
	     */
	    public double quote(double booksPrice){
	        return this.strategy.calcPrice(booksPrice);
	    }
	}
	/**
	* 测试
	*/
	public class Test {
	    public static void main(String[] args) {
	        //选择并创建需要使用的策略对象
	        MemberStrategy strategy = new AdvancedMemberStrategy();
	        //创建环境
	        Price price = new Price(strategy);
	        //计算价格
	        double quote = price.quote(300);
	        System.out.println(&quot;图书的最终价格为：&quot; + quote);
	    }
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;　　从上面的示例可以看出，策略模式仅仅封装算法，提供新的算法插入到已有系统中，以及老算法从系统中“退休”的方法，策略模式并不决定在何时使用何种算法。在什么情况下使用什么算法是由客户端决定的。&lt;/p&gt;
&lt;h4 id=&quot;3模式认知&quot;&gt;      3，模式认知&lt;/h4&gt;

&lt;p&gt;　　●  策略模式的重心&lt;/p&gt;

&lt;p&gt;　　策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。&lt;/p&gt;

&lt;p&gt;　　●  算法的平等性&lt;/p&gt;

&lt;p&gt;　　策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。所以可以这样描述这一系列策略算法：策略算法是相同行为的不同实现。&lt;/p&gt;

&lt;p&gt;　　●  运行时策略的唯一性&lt;/p&gt;

&lt;p&gt;　　运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。&lt;/p&gt;

&lt;p&gt;　　●  公有的行为&lt;/p&gt;

&lt;p&gt;　　经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口。这其实也是典型的将代码向继承等级结构的上方集中的标准做法。
　　&lt;!-- ![edit](/static/assets/img/blog/java/patterns/codefx.png) --&gt;
	&lt;center&gt;&lt;img src=&quot;/static/assets/img/blog/java/patterns/codefx.png&quot; width=&quot;50%&quot; /&gt;&lt;/center&gt;&lt;/p&gt;
&lt;h4 id=&quot;4模式优缺点&quot;&gt;      4，模式优缺点&lt;/h4&gt;

&lt;p&gt;　　●  优点&lt;/p&gt;

&lt;p&gt;　　（1）策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。&lt;/p&gt;

&lt;p&gt;　　（2）使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。&lt;/p&gt;

&lt;p&gt;　　●  缺点&lt;/p&gt;

&lt;p&gt;　　（1）客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。&lt;/p&gt;

&lt;p&gt;　　（2）由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。&lt;/p&gt;
&lt;h1 id=&quot;三引用&quot;&gt;三、引用&lt;/h1&gt;

&lt;p&gt;　　《Head First 设计模式》&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;http://www.cnblogs.com/java-my-life/archive/2012/05/10/2491891.html&quot;&gt;《JAVA与模式》之策略模式&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;/java/2012/04/01/PatternBefore.html&quot;&gt;关于Java设计模式的肤浅看法–前言（一）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;/java/2012/04/03/ObserverPattern.html&quot;&gt;关于Java设计模式的肤浅看法–观察者模式（三）&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;四结束语&quot;&gt;四、结束语&lt;/h1&gt;
&lt;p&gt;　　本篇博客采用的是从实际问题出发，引出问题根源，然后解决问题，然后总结解决方法，抽象成设计原则和设计思想，这种方式远比反过来讲解内容要让人更容易接受的多^_^&lt;/p&gt;

&lt;p&gt;　　&lt;/p&gt;

</description>
        <pubDate>Mon, 02 Apr 2012 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2012/04/02/StrategyPattern.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2012/04/02/StrategyPattern.html</guid>
        
        <category>java</category>
        
        <category>策略模式</category>
        
        
        <category>java</category>
        
      </item>
    
      <item>
        <title>关于Java设计模式的肤浅看法--前言（一）</title>
        <description>&lt;h1 id=&quot;一正文&quot;&gt;一、正文&lt;/h1&gt;
&lt;p&gt;　　笔者看过好多版本的书籍介绍的设计模式，最近又看了看《Head First 设计模式》，感觉中国人和外国人写书写的真的不一样。&lt;/p&gt;

&lt;p&gt;　　中国人思维比较教条，教育体制80后最懂的，深受其害，授课老师往往会在开头讲某个模块的所有知识点，讲完了，然后再讲几道例题，然后剩下的就是同学们的家庭作业了，我说的没错吧？&lt;/p&gt;

&lt;p&gt;　　可是结果如何呢，我们往往会出现老师告诉我们1+2=3，我们却不知道 应用 交换律 得出2+1 = 3，等到老师告诉我们2+1的确等于3，哦，我们才恍然大悟，2+1真的也可以等于3啊。多么滑稽的事情啊 !&lt;/p&gt;

&lt;p&gt;　　不止高中以下的应试教育是这样，连大学所谓的素质教育也是这样，笔者记得清楚的一次是，读研究生时为了通过数学考试去从网上找找 线性代数的教学视频来看，当时找的是美国麻省理工学院的Gilbert Strang教授讲的线代视频，有兴趣的可以去网易公开课看看，当你看完前三集，兴许你就会和我一样有着同样的感悟，为什么和我们原来听过的线性代数课程有那么大的不一样，为什么我会越听越想听Gilbert Strang讲的课程，兴许我还会考虑学学他其他的教学视频，兴许我突然间打开了一扇大门，我可以以后多找些外国人的教学视频来看。那么，为什么会这样呢？&lt;/p&gt;

&lt;p&gt;　　笔者认为，出现上溯问题的根源在于，中国人喜欢从上往下向学生灌输知识和思想，而外国人喜欢从下往上引导，辅助学习者塑造自己的思想。被动接受pk主动获取，必然后者完胜。而且，很无奈的是，从上往下教条式的教书理论上讲没有任何毛病，但是似乎冥冥之中感觉到这却让为师者省了很大一部分力气，为师者只要照本宣科的把知识点讲完，然后再让学生做海量的习题即可，老师省事啊，反正作业又不是他写，习题又不是他算，他只要动动嘴唇，便可将本该属于自己分内责任，教书育人的事情，甩了大部分出去。我们经常从网上看到中国小学生作业多的不行，连家长都看不过去，屡屡曝光家长群里老师布置作业的聊天记录，感觉现在的老师们真的做的有些过分！当然，受限于应试教育的弊病，谁分高谁能进好中学，好高中，好大学的现实，当老师的也是无奈，黔驴技穷了，只能苦了孩子。&lt;/p&gt;

&lt;p&gt;　　话题拉回来，还是谈谈我们学习编程技术的事情。笔者认为，学习就是在输入，而实际工作编程则是在输出，由输入转化为更多的输出则需要我们真正理解其中的技术思想，而在技术更新迭代超快的今天，恰恰技术思想是我们最能拿来当立身之本的东西。这就像为什么老程序员比新程序员学新技术更快，因为老程序员在之前的实际编程工作中潜移默化的掌握了一些编程思想，只是他们不知道罢了。。&lt;/p&gt;

&lt;p&gt;　　再把话题拉到设计模式的跟前，我会沿着《Head First 设计模式》的授课思路学习下去，每每理解完一个设计模式，就写篇博客做个记录。在没有将所学设计模式真正应用到实际开发中去之前，记录便是一种最有效的的输出形式，用过的都说好。&lt;/p&gt;

&lt;p&gt;　　文章中我会借用别人博客中的内容和图片，甚至于代码，当然我会在博客的末尾加上引用出处的链接。如果你喜欢我写的博客，甚至有幸被你分享到自己博客中，也希望你能加上我的博客链接，兴许会有朋友联系我，并帮我指正博客中论述的不足之处，那将会是我万分感激的事情^_^&lt;/p&gt;

&lt;h1 id=&quot;二引用&quot;&gt;二、引用&lt;/h1&gt;

&lt;p&gt;　　&lt;a href=&quot;/java/2012/04/02/StrategyPattern.html&quot;&gt;关于Java设计模式的肤浅看法–策略模式（二）&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 01 Apr 2012 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/java/2012/04/01/PatternBefore.html</link>
        <guid isPermaLink="true">http://localhost:4000/java/2012/04/01/PatternBefore.html</guid>
        
        <category>java</category>
        
        <category>设计模式</category>
        
        
        <category>java</category>
        
      </item>
    
  </channel>
</rss>
